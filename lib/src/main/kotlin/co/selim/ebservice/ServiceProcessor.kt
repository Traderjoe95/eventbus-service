package co.selim.ebservice

import co.selim.ebservice.annotation.EventBusService
import co.selim.ebservice.eventbus.EventBusServiceRequest
import co.selim.ebservice.eventbus.EventBusServiceRequestImpl
import io.vertx.core.Verticle
import kotlinx.coroutines.flow.Flow
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.TypeElement
import javax.lang.model.type.MirroredTypeException
import javax.lang.model.util.ElementFilter

@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedOptions("kapt.kotlin.generated")
@SupportedAnnotationTypes("co.selim.ebservice.annotation.EventBusService")
class ServiceProcessor : AbstractProcessor() {
  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
    val elements = roundEnv.getElementsAnnotatedWithAny(
      setOf(EventBusService::class.java)
    )
    if (elements.isEmpty()) return false

    val typeElements = ElementFilter.typesIn(elements)

    typeElements.forEach { typeElement ->
      typeElement.getAnnotation(EventBusService::class.java)?.let { service ->
        val sourceFilePath = Paths.get(processingEnv.options["kapt.kotlin.generated"]!!)
          .resolve(service.topic.replace(".", File.separator))
          .resolve("Service.kt")
        Files.deleteIfExists(sourceFilePath)
        Files.createDirectories(sourceFilePath.parent)

        val consumedType = service.extractConsumedType()
        val producedType = service.extractProducedType()
        Files.writeString(
          sourceFilePath,
          generateServiceExtensions(
            service.topic,
            consumedType,
            producedType,
            service.propertyName,
            service.functionName
          ),
          StandardOpenOption.CREATE, StandardOpenOption.APPEND
        )
      }
    }

    return true
  }

  private fun EventBusService.extractConsumedType(): Pair<String, String> {
    return extractClass { consumes.java.simpleName to consumes.java.name }
  }

  private fun EventBusService.extractProducedType(): Pair<String, String> {
    return extractClass { produces.java.simpleName to produces.java.name }
  }

  private fun extractClass(block: () -> Pair<String, String>): Pair<String, String> {
    return try {
      block()
    } catch (e: MirroredTypeException) {
      val typeElement = processingEnv.typeUtils.asElement(e.typeMirror) as TypeElement
      typeElement.simpleName.toString() to typeElement.qualifiedName.toString()
    }
  }

  override fun getSupportedAnnotationTypes(): Set<String> {
    return setOf(EventBusService::class.java.name)
  }

  private fun generateServiceExtensions(
    topic: String,
    consumedType: Pair<String, String>,
    producedType: Pair<String, String>,
    propertyName: String,
    functionName: String
  ): String {
    return buildString {
      appendLine(generateHeader(topic, consumedType.second, producedType.second))
      appendLine()
      appendLine(generateRequestsProperty(consumedType.first, producedType.first, propertyName))
      appendLine()
      appendLine(generateRequestFunction(consumedType.first, producedType.first, functionName))
    }
  }
}

private fun generateHeader(
  topic: String,
  consumedTypeQualified: String,
  producedTypeQualified: String
): String {
  val sortedServiceTypes = arrayOf(consumedTypeQualified, producedTypeQualified).sortedArray()
  return """
      package $topic

      import ${Verticle::class.qualifiedName}
      import io.vertx.kotlin.coroutines.await
      import io.vertx.kotlin.coroutines.toChannel

      import co.selim.ebservice.eventbus.deliveryOptions
      import ${EventBusServiceRequest::class.qualifiedName}
      import ${EventBusServiceRequestImpl::class.qualifiedName}

      import ${Flow::class.qualifiedName}
      import kotlinx.coroutines.flow.map
      import kotlinx.coroutines.flow.receiveAsFlow

      import ${sortedServiceTypes[0]}
      import ${sortedServiceTypes[1]}
      
      private const val TOPIC = "$topic"

      // This file is automatically generated.
  """.trimIndent()
}

private fun generateRequestsProperty(
  requestType: String,
  responseType: String,
  propertyName: String
): String {
  return """
      val ${Verticle::class.simpleName}.$propertyName: ${Flow::class.simpleName}<${EventBusServiceRequest::class.simpleName}<$requestType, $responseType>>
        get() = vertx.eventBus()
          .consumer<${requestType}>(TOPIC)
          .toChannel(vertx)
          .receiveAsFlow()
          .map { ${EventBusServiceRequestImpl::class.simpleName}<$requestType, $responseType>(it) }
  """.trimIndent()
}

fun generateRequestFunction(
  requestType: String,
  responseType: String,
  functionName: String
): String {
  return """
      suspend fun Verticle.$functionName(request: ${requestType}): $responseType = vertx.eventBus()
        .request<${responseType}>(TOPIC, request, deliveryOptions)
        .await()
        .body()
  """.trimIndent()
}
