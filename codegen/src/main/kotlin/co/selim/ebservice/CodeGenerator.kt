package co.selim.ebservice

import co.selim.ebservice.core.EventBusServiceRequest
import co.selim.ebservice.core.EventBusServiceRequestImpl
import io.vertx.core.Verticle
import kotlinx.coroutines.flow.Flow

internal fun generateHeader(
  topic: String,
  consumedTypeQualified: String,
  producedTypeQualified: String
): String {
  val sortedServiceTypes = arrayOf(consumedTypeQualified, producedTypeQualified).sortedArray()
  return """
      package $topic

      import ${Verticle::class.qualifiedName}
      import io.vertx.kotlin.coroutines.await
      import io.vertx.kotlin.coroutines.toChannel

      import co.selim.ebservice.core.deliveryOptions
      import ${EventBusServiceRequest::class.qualifiedName}
      import ${EventBusServiceRequestImpl::class.qualifiedName}

      import ${Flow::class.qualifiedName}
      import kotlinx.coroutines.flow.map
      import kotlinx.coroutines.flow.receiveAsFlow

      import ${sortedServiceTypes[0]}
      import ${sortedServiceTypes[1]}

      // This file is automatically generated.

      private const val TOPIC = "$topic"
  """.trimIndent()
}

internal fun generateRequestsProperty(
  requestType: String,
  responseType: String,
  propertyName: String
): String {
  return """
      val ${Verticle::class.simpleName}.$propertyName: ${Flow::class.simpleName}<${EventBusServiceRequest::class.simpleName}<$requestType, $responseType>>
        get() = vertx.eventBus()
          .consumer<${requestType}>(TOPIC)
          .toChannel(vertx)
          .receiveAsFlow()
          .map { ${EventBusServiceRequestImpl::class.simpleName}<$requestType, $responseType>(it) }
  """.trimIndent()
}

internal fun generateRequestFunction(
  requestType: String,
  responseType: String,
  functionName: String
): String {
  return """
      suspend fun Verticle.$functionName(request: ${requestType}): $responseType = vertx.eventBus()
        .request<${responseType}>(TOPIC, request, deliveryOptions)
        .await()
        .body()
  """.trimIndent()
}
